<!doctype html>
<head>
  <script type="text/javascript" src="../src/lokijs.js"></script>
  <script type="text/javascript" src="../src/incremental-indexeddb-adapter.js"></script>
</head>
<h2>Hi!</h2>

<script>
  var db

  function start() {
    indexedDB.deleteDatabase("IncrementalAdapterIDB")

    let adapter = new IncrementalIndexedDBAdapter()
    db = new loki('indexed_tests', { adapter: adapter, verbose: true });

    let col1 = db.addCollection('test_collection')
    let col2 = db.addCollection('test_collection2')

    col1.insert({  customId: 0,  val: 'hello', constraints: 100 });
    col1.insert({  customId: 1,  val: 'hello1' });
    let h2 = col1.insert({  customId: 2,  val: 'hello2' });
    let h3 = col1.insert({  customId: 3,  val: 'hello3' });
    let h4 = col1.insert({  customId: 4,  val: 'hello4' });
    let h5 = col1.insert({  customId: 5,  val: 'hello5' });

    h2.val = 'UPDATED'
    col1.update(h2)

    h3.val = 'UPDATED'
    col1.update(h3)
    h3.val2 = 'added!'
    col1.update(h3)

    col1.remove(h4)

    let h6 = col1.insert({  customId: 6,  val: 'hello6' });

    // console.log(db)
    // console.log(col1)

    // console.log(JSON.parse(db.serialize()))

    // console.log(col1.lokiIdChanges)

    db.collections.forEach(col => {
      console.time('massAdd')
      const numberOfRecords = 32000
      for (let i = 0; i < numberOfRecords; i++) {
        col.insert({ mass: true, i, blah: 'accumsan congue. Lorem ipsum primis in nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam. nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam. Ut sagittis, ipsum dolor quam. nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam' })
      }
      console.timeEnd('massAdd')

      // remove many contiguous records to have empty chunks
      const dataToDelete = col.data.slice(200, 95)
      col.remove(dataToDelete)

      // fuzz changes
      const numberOfDeletions = 2500
      for (let i = 0;i<numberOfDeletions;i++) {
        const id = Math.floor(Math.random() * col.data.length)
        col.remove(col.data[id])
      }

      const numberOfUpdates = 2500
      for (let i = 0;i<numberOfUpdates;i++) {
        const id = Math.floor(Math.random() * col.data.length)
        const doc = col.data[id]
        doc.blah = 'UPDATED_' + doc.blah
        col.update(doc)
      }
    })

    function saveAndCheckIntegrity(source, callback) {
      const before = new Date()
      source.saveDatabase((e) => {
        e && console.error(e)
        console.warn('=====> Database saved! - in ' + (new Date - before) + 'ms')

        // test loading
        const beforeLoad = new Date()
        let db2 = new loki('indexed_tests', { adapter: new IncrementalIndexedDBAdapter(), verbose: true });
        db2.loadDatabase({}, () => {
          console.warn(`====> Loaded database! - in ${new Date() - beforeLoad}ms`)

          // make sure the two databases are identical
          source.collections.forEach((col, ci) => {
            if (!col.data.every((el, i) => {
              const val = JSON.stringify(db2.collections[ci].data[i]) === JSON.stringify(el)
              if (!val) {
                debugger
              }
              return val
            }
            )) {
              debugger
              throw new Error('different dbs')
            }
          })
          console.log(`Passed the checks!`)
          callback()
        })
      })
    }

    // test save, test loading & check if incremental save was correct
    saveAndCheckIntegrity(db, () => {
      console.info(`---- do a second save with only some minor changes -----------`)

      const col = db.collections[0]

      col.insert({ small: true, incremental: true, change: 'heck yeah'})

      const someRandomRecordToDelete = col.data[100]
      col.remove(someRandomRecordToDelete)

      const someRandomRecordToUpdate = col.data[1000]
      someRandomRecordToUpdate.updated = true
      col.update(someRandomRecordToUpdate)

      saveAndCheckIntegrity(db, () => {
        console.info(`---- begin long running fuzz tests -----------`)

        function fuzz(db) {
          db.collections.forEach(col => {
            const changeSize = Math.random()
            const sizeFactor = changeSize < 0.1 ? 0.1 : changeSize > 0.9 ? 10 : 1

            const numberOfInsertions = 20 * sizeFactor
            const numberOfDeletions = 15 * sizeFactor
            const numberOfUpdates = 15 * sizeFactor
            const total = numberOfInsertions + numberOfDeletions+numberOfUpdates

            console.log(`Fuzzed changes size: ${total}`)

            // inserts
            for (let i = 0; i < numberOfInsertions; i++) {
              col.insert({ mass: true, i, blah: 'accumsan congue. Lorem ipsum primis in nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam. nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam. Ut sagittis, ipsum dolor quam. nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam' })
            }

            // deletions
            for (let i = 0;i<numberOfDeletions;i++) {
              const id = Math.floor(Math.random() * col.data.length)
              col.remove(col.data[id])
            }

            // updates
            for (let i = 0;i<numberOfUpdates;i++) {
              const id = Math.floor(Math.random() * col.data.length)
              const doc = col.data[id]
              doc.blah = 'UPDATED_' + doc.blah
              col.update(doc)
            }
          })
        }

        function performFuzzAndCheck(db) {
          return new Promise((resolve, reject) => {
            fuzz(db)
            saveAndCheckIntegrity(db, resolve)
          })
        }

        async function runFuzzes(count, callback) {
          for (let i = 0; i < count; i++) {
            await performFuzzAndCheck(db)
          }

          callback()
        }

        runFuzzes(100, () => {
          console.log(`All tests passed!`)
        })
      })
    })
  }

  // ------ IndexedDB performance tests -------




  function modifyEntireIDB(create = false) {
      console.time('saveIDB')
      create && indexedDB.deleteDatabase("IDBTest2")
    let openRequest = indexedDB.open('IDBTest2', 1);
    openRequest.onupgradeneeded = e => {
      if (create) {

        var thisDB = e.target.result;

        let objectStore = thisDB.createObjectStore('TestStore2', { keyPath: 'key' });
      } else {
        throw new Error('idb doesnt exist')
      }
    }
    openRequest.onsuccess = e => {
      let db = e.target.result

      let tx = db.transaction(['TestStore2'], 'readwrite')

      tx.oncomplete = () => {
      console.timeEnd('saveIDB')
      }

      let store = tx.objectStore('TestStore2')

      const method = create ? 'add' : 'put'

      store[method]({ key: 'metadata', val: { collections: {} } })


      console.time('addmany')
      for (let i = 0; i < 650; i++) {
        let bsObject = Array(100).fill(null).map(() => ({ foo: 'asdasdasd', bar: 123, b: true, blah: 'accumsan congue. Lorem ipsum primis in nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam. nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam' }))

        store[method]({ key: 'bchunk.blah.' + i, val: JSON.stringify(bsObject) })
      }
      console.timeEnd('addmany')

    }
  }

  function createIDB() {
    modifyEntireIDB(true)
  }

  function modifyIDB() {
    console.time('modifyIDB')
    let openRequest = indexedDB.open('IDBTest2', 1);
    openRequest.onupgradeneeded = e => {
      throw new Error('idb doesnt exist')
    }
    openRequest.onsuccess = e => {
    console.time('sync-lock-time')
      let db = e.target.result

      let tx = db.transaction(['TestStore2'], 'readwrite')

      tx.oncomplete = () => {
      console.timeEnd('modifyIDB')
      }

      let store = tx.objectStore('TestStore2')

      let bsObject = Array(100).fill(null).map(() => ({ foo: 'asdasdasd', bar: 123, b: true, blah: 'accumsan congue. Lorem ipsum primis in nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam. nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam' }))

      store.put({ key: 'bchunk.blah.0', val: JSON.stringify(bsObject) })
    console.timeEnd('sync-lock-time')

    }
  }

  function createIDBBigBlob() {
      console.time('saveIDBBlob')
      indexedDB.deleteDatabase("IDBTestBlob")
    let openRequest = indexedDB.open('IDBTestBlob', 1);
    openRequest.onupgradeneeded = e => {
      var thisDB = e.target.result;

      let objectStore = thisDB.createObjectStore('TestStore2', { keyPath: 'key' });
    }
    openRequest.onsuccess = e => {
      let db = e.target.result

      let tx = db.transaction(['TestStore2'], 'readwrite')
      let store = tx.objectStore('TestStore2')

      let loki = { chunks: [] }
      console.time('addmany')
      for (let i = 0; i < 65000; i++) {
        let bsObject = { foo: 'asdasdasd', bar: 123, b: true, blah: 'accumsan congue. Lorem ipsum primis in nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam. nibh vel risus. Sed vel lectus. Ut sagittis, ipsum dolor quam' }

        loki.chunks.push({ key: 'chunk.blah.' + i, val: bsObject })
      }
      console.timeEnd('addmany')


      store.add({ key: 'db', val: JSON.stringify(loki) })

      tx.oncomplete = () => {
      console.timeEnd('saveIDBBlob')
      }
    }
  }

  start()
  // createIDB() // takes 250-300ms in Safari to insert 650 chunks, 100 elements each; chrome: 350; firefox: 125
  // modifyIDB() // ~12-20ms for saving one 100-el chunk; chrome: 10ms; ff: 15
  // modifyEntireIDB() // worst case scenario: 210-240ms; ff: 100-150
  // createIDBBigBlob() // 360ms - 65000 elements in one big JSON chunk; chrome: 360-400; ff: 350-400
</script>
